(assign fs (require 'fs))

(assign gensym-counter 0)

(def gensym (prefix)
  (do1
    (str (or prefix '"") '_g gensym-counter)
    (++ gensym-counter)))

(assign reps (obj < '_lt + '_p = '_eq ` '_qq | '_pipe * '_st - '_d _ '__ / '_s))

(assign wholereps (obj if 'if_ else 'else_ with 'with_ var 'var_ case 'case_))

(def munge (x)
  (if (or (! (astr x)) (is (get x 0) '"\""))
    x
    (or (get wholereps x)
	(join (map (fn (y)
		     (or (get reps y) y))
		   x)
	      '""))))

(def letmac (name val 'body)
  (if (alist name)
      (with (offset (if (anumber (first name))
			(do1
			  (first name)
			  (= name (slice name 1)))
			0)
	     (before (rest 'after)) (split-by (fn (arg)
						(and (alist arg)
						     (is (get arg 0) '')))
					      name)
	     rest (if rest
		      (second rest)
		      false))
	(if (is name.length 0)
	    `(do ,@body)
	    (w/uniq g
	      (each (i name) before
		(= body `((let ,name (get ,g ,(+ offset i))
			    ,@body))))
	      (when rest
		(= body `((let ,rest (slice ,g ,(+ offset before.length)
					    (- (, g).length ,after.length))
			    ,@body)))
		(each (i name) after
		  (= body `((let ,name (get ,g (- (, g).length ,(- after.length i)))
			      ,@body)))))
	      `(let ,g ,val
		 ,@body))))
      `(rawlet ,name ,val ,@body)))

(def fun (name args 'body)
  (let (before restnafter) (split-by (fn (arg) (and (alist arg)
						    (is (get arg 0) '')))
				     args)
    (each arg before
      (when (alist arg)
	(w/uniq sub
	  (= body `((let ,arg ,sub
		      ,@body)))
	  (= arg sub))))
    `(rawfun ,name ,before
       (let (,before.length ,@restnafter) arguments
	 ,@body))))

(def asbool (x)
  (w/uniq g
    `(let ,g ,x
       (if (and (alist ,g) (is (, g).length 0))
	   false
	   (if (is ,g 0)
	       true
	       ,g)))))

(def ifmac (cond then 'rest)
  `(rawif ,cond ,then ,(if (is rest.length 0)
			   null
			   (is rest.length 1)
			   (get rest 0)
			   `(if ,@rest))))

(def lifmac (cond then 'rest)
  `(rawif ,(asbool cond) ,then ,(if (is rest.length 0)
				    null
				    (is rest.length 1)
				    (get rest 0)
				    `(lif ,@rest))))

(assign macs (obj if ifmac fun fun let letmac lif lifmac))

(def commaop ('code)
  (join (map rendex code) '", "))

(def delet (code)
  (if (alist code)
      (if (is (get code 0) 'rawlet)
	  (with ((vars (name val 'body)) (delet (slice code 1))
		 sub (gensym name))
	    (list (cat vars (list sub))
		  `(do (= ,sub ,val)
		       ,@(subsname name sub body))))
	  (is (get code 0) 'rawfun)
	  (list () code)
	  (let foo (map delet code)
	    (list (mapcat first foo) (map second foo))))
      (list () code)))

(def rawif (cond then else_)
  (str (rendex cond) '" ? " (rendex then) '" : " (rendex else_)))

(def rawwhile (cond 'body)
  (str '"function () {while (" (rendex cond) '") {\n    " (apply commaop body) '";\n}}()"))

(def rawcatch (name form 'body)
  (str '"function () {try{\n    return " (rendex form) '"} catch (" (rendex name) '") {\n    return " (apply commaop body) '";\n}}()"))

(def funcall (name args)
  (str (rendex name) '"(" (apply commaop args) '")"))

(def rawget (a b)
  (str (rendex a) '"[" (rendex b) '"]"))

(def quote (a)
  (JSON.stringify a))

(def pp (a)
  (str '"++" (rendex a)))

(def r-asnumber (a)
  (str '+ (rendex a)))

(def rawfun (name args 'body)
  (let (names body) (delet (cat '(do) body))
    (str '"function " (munge name) '" (" (apply commaop args) '") {\n"
	 (if (is names.length 0)
	     '""
	     (str '"    var " (apply commaop names) '";\n"))
	 '"    return " (rendex body) '"\n}")))

(assign exprenderers (obj get rawget rawfun rawfun ' quote ++ pp while rawwhile
			  rawif rawif do commaop asnumber r-asnumber
			  catch rawcatch))

(map (fn ((name op id))
       (= (get exprenderers name) (fn ('xs)
				    (if (is xs.length 0)
					id
					(join (map rendex xs) op)))))
     '((. . null)
       (+ " + " 0)
       (% " % " 0)
       (- " - " 0)
       (/ " / " 1)
       (and " && " true)
       (or " || " false)
       (raw< " < " true)
       (raw<= " <= " true)
       (= " = " null)
       (rawis " === " true)))

(map (fn ((name op))
       (= (get macs name) (fn ('xs)
			    (if (< xs.length 2)
				true
				(is xs.length 2)
				(list op (get xs 0) (get xs 1))
				(w/uniq (g1 g2)
				  `(with (,g1 ,(get xs 0)
					  ,g2 ,(get xs 1))
				     (and (,op ,g1 ,g2)
					  (,name ,g2 ,@(slice xs 2)))))))))
     '((< raw<)
       (<= raw<=)
       (is rawis)))

(def rendex (code)
  (if (alist code)
      (if (is code.length 0)
	  '"[]"
	  (aif (get exprenderers (get code 0))
	       (str '"(" (apply it (slice code 1)) '")")
	       (str '"(" (funcall (get code 0) (slice code 1)) '")")))
      (if (is code null)
	  'null
	  (is code undefined)
	  'undefined
	  (munge code))))

(def macex (macs code)
  (if (and (alist code) (get code 0) (! (is (get code 0) '')))
      (do
	(= (get code 0) (macex macs (get code 0)))
	(aif (get macs (get code 0))
	     (macex macs (apply it (slice code 1)))
	     (map (fn (x) (macex macs x)) code)))
      code))

(assign env (list (list 'gensym gensym)
		  (list 'require require)))

(def eval-with (code env)
  (apply (Function (map first env) code)
	 (map second env)))

(def eval-form (verb arg code)
  ((case verb
     assign (fn (x) (env.push (list (munge arg) x)))
     assign-mac (fn (x) (= (get macs arg) x))
     run idfn)
   (eval-with (str '"return " code) env)))

(def only-compile-form (verb arg code)
  (str ((case verb
	  assign (fn (x) (str '"var " (munge arg) '" = " x))
	  assign-mac JSON.stringify
	  run idfn)
	code) '";\n"))

(def compile-helper (code)
  (with (foo (macex macs code)
	 (verb arg bar) (if (some (get foo 0) '(assign assign-mac))
			    foo
			    (list 'run null foo))
	 jscode (rendex bar))
    (list verb arg jscode)))

(def compile-form (code)
  (let foo (compile-helper code)
    (if (no (is (get foo 0) 'run))
	(apply eval-form foo))
    (apply only-compile-form foo)))

(def compile (code)
  (join `("\"use strict\";\n" ,@(map compile-form code)) '""))

(def parse (data f)
  (let foo (pfile (str data) 0)
    (lif (second foo)
	 (f (first foo))
	 (prn (first foo)))))

(def read-first-file (paths f)
  ((fun self (ps)
     (if (is ps.length 0)
	 (f null)
	 (callback (fs.readFile (first ps)) (err data)
	   (if err
	       (self (slice ps 1))
	       (f data)))))
   paths))

(def gather-callbacks (cbs f)
  (let res (map (fn () undefined) cbs)
    (cbs.map (fn (cb i)
	       (cb (fn (x)
		     (= (get res i) x)
		     (if (res.every (fn (y) (! (is y undefined))))
			 (f res))))))))

(assign run-repl (is (get process.argv 2) '-i))

(assign files (slice process.argv (if run-repl 3 2)))

(def now ()
  (/ ((new Date).getTime) 1000))


(def repl ()
  (let rl ((require 'readline).createInterface (obj input process.stdin
						    output process.stdout))
    (rl.setPrompt '"Â¿ ")
    (rl.prompt)
    (callback (rl.on 'line) (line)
      (callback (parse line) ((code))
	(prn (catch e (apply eval-form (compile-helper code))
	       e.stack))
	(rl.prompt)))))

(assign start (now))

(callback (gather-callbacks (map (fn (file)
				   (fn (f)
				     (callback (fs.readFile file) (err data)
				       (if err
					   (prn err)
					   (parse data f)))))
				 `(,(str _dirname '"/jasper.jpr") ,@files)))
	  (codes)
  (prn (- (now) start))
  (with (code (apply cat codes)
	 output (compile code))
    (if (no run-repl)
	(fs.writeFileSync (str (get files (- files.length 1)) '".js") output)))
  (prn (- (now) start))
  (if run-repl
      (repl)))