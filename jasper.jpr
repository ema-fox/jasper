(assign slice (fun slice (xs start end)
		   (().slice.call xs start end)))

(assign list (fun list ('xs) xs))

(assign-mac mac (fun mac (name 'argsnbody)
		     (list 'assign-mac name ((list 'fun name).concat argsnbody))))

(mac def (name 'argsnbody)
  (list 'assign name ((list 'fun name).concat argsnbody)))

(def cat ('xs)
  (().concat.apply () xs))

(def join (xs x)
  (().join.call xs x))

(def str ('xs)
  (join xs '""))

(def alist (x)
  (and x (is x.constructor Array)))

(def astr (x)
  (and x (is x.constructor String)))

(def apply (f 'argsa argsb)
  (f.apply null (cat argsa argsb)))

(def map1 (f xs)
  (().map.call xs (fun "" (x) (f x))))

(def map (f 'xss)
  (if (is xss.length 1)
      (map1 f (get xss 0))
      (let length (apply Math.min (prn (map1 (fun "" (x) x.length) xss)))
	(let ys ()
	  (let i 0
	    (console.warn length ys i xss)
	    (while (< i length)
	      (ys.push (apply f (map1 (fun "" (x) (get x i)) xss)))
	      (++ i)))
	  ys))))

(def prn (a 'as)
  (apply console.log a as)
  a)

(def mapcat (f 'xss)
  (apply cat (apply map f xss)))

(def quote (a)
  (JSON.stringify a))

(def runqq (a)
  (if (alist a)
      (if (is (get a 0) ',@)
	  (get a 1)
	  (is (get a 0) ',)
	  (list 'list (get a 1))
	  (list 'list (cat '(cat) (map runqq a))))
      (cat '(list) (quote a))))

(mac ` (a)
    (list 'get (runqq a) 0))

(mac fn (args 'body)
  `(fun "" ,args ,@body))

(mac when (cond 'body)
  `(if ,cond (do ,@body)))

(def subsname (name sub code)
  (if (alist code)
      (if (is (get code 0) '.)
	  `(. ,(subsname name sub (get code 1)) ,@(slice code 2))
	  (map (fn (x) (subsname name sub x)) code))
      (is code name)
      sub
      code))

(def first ((a _)) a)
(def second ((_ a)) a)

(mac with (bindings 'body)
  (if (is bindings.length 0)
      `(do ,@body)
      `(let ,(first bindings) ,(second bindings)
	 (with ,(slice bindings 2)
	   ,@body))))

(mac aif (expr then else_)
  `(let it ,expr
     (if it ,then ,else_)))

(def listify (x)
  (if (alist x)
      x
      (list x)))

(mac w/uniq (names 'body)
  `(with ,(mapcat (fn (n) (list n `(gensym ',n)))
		  (listify names))
	 ,@body))

(mac do1 (x 'xs)
  (w/uniq g
    `(let ,g ,x
       ,@xs
       ,g)))

(mac zap (f place 'args)
  `(= ,place (,f ,place ,@args)))

(def pair (xs)
  (with (ys ()
	 i 0)
    (while (< i xs.length)
      (ys.push (list (get xs i) (get xs (+ i 1))))
      (zap + i 2))
    ys))

(def list2obj (args)
  (let res (Object.create null)
    (map (fn ((k v)) (= (get res k) v))
	 args)
    res))

(mac obj ('args)
  `(list2obj (list ,@(map (fn ((k v))
                            `(list ',k ,v))
                          (pair args)))))

(mac each (iv xs 'body)
  (with (i null v null)
    (if (alist iv)
	(do
	  (= i (first iv))
	  (= v (second iv)))
	(do
	  (= i (gensym i))
	  (= v iv)))
    `(let ,i 0
       (while (< ,i (, xs).length)
	 ,@(subsname v `(get ,xs ,i) body)
	 (++ ,i)))))

(def index-by (f xs)
  (let index false
    (each (i v) xs
      (if (f v)
	  (= index i)))
    index))

(def split-by (f xs)
  (let i (index-by f xs)
    (if (is i false)
	(list xs ())
	(list (slice xs 0 i) (slice xs i)))))

(mac callback (to from 'body)
  `(,@to (fn ,from ,@body)))


'"non core:"


(def dbg (x)
  (prn (JSON.stringify x))
  x)

(assign sqrt Math.sqrt)
(assign ** Math.pow)

(def distance ((pa0 pa1) (pb0 pb1))
  (sqrt (+ (** (- pb0 pa0) 2)
	   (** (- pb1 pa1) 2))))

(def plus ((pa0 pa1) (pb0 pb1))
  (list (+ pa0 pb0) (+ pa1 pb1)))

(assign ngbroffsets (list (list 1 0) (list 0 1) (list -1 0) (list 0 -1)))
